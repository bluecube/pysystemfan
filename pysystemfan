#!/usr/bin/env python3

import heapq
import shlex
import subprocess
import json
import collections
import time

def _number_from_file(filename):
    with open(filename, "r") as fp:
        return int(fp.readline())

def _process_params(obj, dictionary):
    for name, default, description in obj._params:
        value = dictionary.get(name, default)
        if value is None:
            raise RuntimeError("Value of parameter " + name + " must be set")
        setattr(obj, name, value)

def _dump_params(obj):
    ret = collections.OrderedDict()
    for name, default, desription in obj._params:
        ret[name] = getattr(obj, name)
    return ret

def _json_dump_compact(data):
    return json.dumps(data, indent=None, separators=",:")

def _json_dump_indented(data):
    return json.dumps(data, indent=4, separators=(",", ": "))

def load_fans():
    with open("pysystemfan.json", "r") as fp:
        config = json.load(fp)

    return [Fan(**fan_params) for fan_params in config]

class Fan:
    _params = [
        ("pwm_path", None, "Path in (typically /sys/class/hwmon/hwmon?/pwm?) that is used to set fan pwm setting"),
        ("rpm_path", None, "Path in (typically /sys/class/hwmon/hwmon?/fan?_input) that is used to set rpm"),

        ("name", "", "Optional name that wil appear in status output if present"),
        ("sleep_time", 30, "How long to sleep between updates (seconds)."),
        ("min_pwm", 64, "Minimal allowed nonzero PWM value. Below this the fan will stop in normal mode, or stay on minimum in settle mode."),
        ("spinup_pwm", 128, "PWM value to spin the fan up."),
        ("spinup_time", 1, "How long the spinup_pwm will be applied (seconds)."),
        ("settle_update_count", 0, "How many updates after spinning up will the fan be in settle mode (prevented spin down)."),

        ("thermometers", None, "List of thermometers controling this fan")
    ]

    STOPPED = 0
    SETTLE = 1
    RUNNING = 2

    def __init__(self, **params):
        _process_params(self, params)

        self._state = self.STOPPED if self.get_rpm() == 0 else self.SETTLE
        self._settle_remaining = self.settle_update_count

        self.thermometers = [Thermometer(self, **thermometer_params) for thermometer_params in params["thermometers"]]

    def spinup(self):
        self.set_pwm(self.spinup_pwm)
        yield self.spinup_time
        self._state = self.SETTLE
        self._settle_remaining = self.settle_update_count

    def stop(self):
        self.set_pwm(0)
        self._state = self.STOPPED

    def get_rpm(self):
        return _number_from_file(self.rpm_path)

    def set_pwm(self, value):
        with open(self.pwm_path, "w") as fp:
            print("setting pwm to:", value)
            print(str(value), file=fp)

    def update_loop(self):
        while True:
            if self._state == self.STOPPED:
                if any(thermometer.need_fan() for thermometer in self.thermometers):
                    yield from self.spinup()
                else:
                    yield self.sleep_time
            else:
                if self._state == self.SETTLE:
                    if self._settle_remaining <= 0:
                        self._state = self.RUNNING
                    else:
                        self._settle_remaining -= 1

                pwm = max(thermometer.requiered_fan_pwm() for thermometer in self.thermometers)
                if pwm < self.min_pwm:
                    if self._state != self.SETTLE and not any(thermometer.need_fan() for thermometer in self.thermometers):
                        self.stop()
                    else:
                        self.set_pwm(self.min_pwm)
                elif pwm > 255:
                    self.set_pwm(255)
                else:
                    self.set_pwm(round(pwm))

                yield self.sleep_time

    def calibrate():
        raise NotImplementedError();

    def status(self):
        ret = {
            "rpm": self.get_rpm(),
            "thermometers": [thermometer.status() for thermometer in self.thermometers],
            "_state": {self.RUNNING: "running", self.SETTLE: "settle", self.STOPPED: "stopped"}[self._state]
        }
        if self.name:
            ret["name"] = self.name
        return ret

    def config(self):
        ret = _dump_params(self)
        ret["thermometers"] = [thermometer.config() for thermometer in self.thermometers]
        return ret

    def __iter__(self):
        return (time.time() + sleep_time for sleep_time in self.update_loop())

class Thermometer:
    _smartctl_prefix = "smartctl:"

    _params = [
        ("path", None, "Path in /sys (typically /sys/class/hwmon/hwmon?/temp?_input) that has the temperature. Alternatively a string like '" + _smartctl_prefix + "/dev/sda' can be used for temperatures from smartctl"),

        ("name", "", "Optional name that wil appear in status output if present"),

        ("target_temperature", None, "Temperature we are trying to reach when the fan is running"),
        ("fan_start_temperature", -100, "Temperature at which the fan needs to start. Set higher than target_temperature to be able to stop the fan, or very low to prevent spinning down the fan."),

        ("kP", 20, "Proportional constant of the controler."),
        ("kI", 10, "Integration constant of the controller."),
        ("kD", 20, "Derivation constant of the controller."),

        ("derivative_smoothing_window", 5, "Number of updates to use as a smoothing window for derivative term")
    ]

    def __init__(self, fan, **params):
        _process_params(self, params)

        self._anti_windup = 300 / self.kI

        self._last_temperature = collections.deque([self.get_temperature()], self.derivative_smoothing_window)
        self._integral = fan.min_pwm / self.kI

    def get_temperature(self):
        if self.path.startswith(self._smartctl_prefix):
            return self._get_smartctl_temperature(self.path[len(self._smartctl_prefix):])
        else:
            return _number_from_file(self.path) / 1000

    @staticmethod
    def _get_smartctl_temperature(arguments):
        command = ["smartctl", "-a"] + shlex.split(arguments)
        process = subprocess.Popen(command,
                                   stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL,
                                   universal_newlines=True)
        for line in process.stdout:
            split = line.split()
            if len(split) >= 10 and split[1] == "Temperature_Celsius":
                return int(split[9])

        if process.wait():
            raise RuntimeError("Command {} failed with return code {}".format(str(command), process.returncode))
        else:
            raise RuntimeError("Didn't find temperature in output of command {}".format(str(command)))

    def need_fan(self):
        return self.get_temperature() >= self.fan_start_temperature

    def requiered_fan_pwm(self):
        temperature = self.get_temperature()

        error = temperature - self.target_temperature

        self._integral += error
        if self._integral > self._anti_windup:
            self._integral = self._anti_windup
        elif self._integral < -self._anti_windup:
            self._integral = -self._anti_windup

        derivation = temperature - self._last_temperature[0]

        ret = self.kP * error + self.kI * self._integral + self.kD * derivation

        self._last_temperature.append(temperature)

        return ret

    def status(self):
        ret = {
            "temperature": self.get_temperature(),
            "need_fan": self.need_fan(),
            "_integral": self._integral,
            "_smoothed_last_temperature": self._last_temperature[0]
        }
        if self.name:
            ret["name"] = self.name
        return ret

    def config(self):
        return _dump_params(self)

def status(fans):
    return [fan.status() for fan in fans]

def main():
    fans = load_fans()

    try:
        wakeup_times = [iter(f) for f in fans]
        for wakeup_time in heapq.merge(*wakeup_times):
            print(_json_dump_indented(status(fans)), time.time())
            time.sleep(wakeup_time - time.time())
    finally:
        for fan in fans:
            fan.set_pwm(255)

if __name__ == "__main__":
    main()
